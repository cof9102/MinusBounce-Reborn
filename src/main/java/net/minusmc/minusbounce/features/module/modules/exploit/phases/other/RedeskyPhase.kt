package net.minusmc.minusbounce.features.module.modules.exploit.phases.other

import net.minusmc.minusbounce.event.BlockBBEvent
import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minecraft.block.BlockAir
import net.minecraft.util.AxisAlignedBB

class RedeskyPhase : PhaseMode("Redesky") {
	private var stage = 0

	override fun onEnable() {
		stage = 0
		mc.timer.timerSpeed = 0.1f
	}

	override fun onDisable() {
		mc.timer.timerSpeed = 1f
	}
	
	override fun onUpdate() {
		when (stage) {
			1 -> {
				mc.netHandler.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY + -0.00000001, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                mc.netHandler.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
			}
			3 -> phase.state = false
		}

		stage++
	}

	override fun onBlockBB(event: BlockBBEvent) {
        val entityBoundingBox = mc.thePlayer.entityBoundingBox ?: return
        val boundingBox = event.boundingBox ?: return
        if (BlockUtils.collideBlockIntersects(entityBoundingBox) { it !is BlockAir } && boundingBox.maxY > entityBoundingBox.minY)
            event.boundingBox = AxisAlignedBB(boundingBox.maxX, entityBoundingBox.minY, boundingBox.maxZ, boundingBox.minX, boundingBox.minY, boundingBox.minZ)
    }
}