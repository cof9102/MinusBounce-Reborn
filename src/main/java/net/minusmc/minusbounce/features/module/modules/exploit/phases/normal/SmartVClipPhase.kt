package net.minusmc.minusbounce.features.module.modules.exploit.phases.normal

import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minusmc.minusbounce.event.SentPacketEvent
import net.minusmc.minusbounce.event.JumpEvent
import net.minusmc.minusbounce.event.MoveEvent
import net.minusmc.minusbounce.event.BlockBBEvent
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.BlockPos
import net.minecraft.block.BlockAir
import net.minecraft.util.AxisAlignedBB


class SmartVClipPhase : PhaseMode("SmartVClip") {
	private var noRot = false
	
	override fun onUpdate() {
		val firstBlock = BlockUtils.getBlock(BlockPos(mc.thePlayer).up(3))
		val secondBlock = BlockUtils.getBlock(BlockPos(mc.thePlayer).down())

		val cageCollision = firstBlock !is BlockAir && secondBlock !is BlockAir
        
        noRot = mc.thePlayer.ticksExisted in 0..40 && cageCollision

        if (mc.thePlayer.ticksExisted in 20..39 && cageCollision) {
            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ, false))
            mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ)
        }	
	}

	override fun onSentPacket(event: SentPacketEvent) {
		val packet = event.packet

		if (!noRot)
			return

		if (packet is C03PacketPlayer && packet.rotating)
			event.isCancelled = true

		if (packet is C0BPacketEntityAction)
			event.isCancelled = true
	}

	override fun onMove(event: MoveEvent) {
		if (noRot)
			event.zeroXZ()
	} 

	override fun onJump(event: JumpEvent) {
		if (noRot)
			event.isCancelled = true
	}
}
