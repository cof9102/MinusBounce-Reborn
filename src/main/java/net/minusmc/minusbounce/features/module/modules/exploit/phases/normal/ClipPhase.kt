package net.minusmc.minusbounce.features.module.modules.exploit.phases.normal

import net.minecraft.util.AxisAlignedBB
import net.minecraft.block.BlockAir
import net.minecraft.util.BlockPos
import net.minusmc.minusbounce.event.BlockBBEvent
import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minusmc.minusbounce.utils.misc.MathUtils
import kotlin.math.cos
import kotlin.math.sin

class ClipPhase : PhaseMode("Clip") {
	private var ticks = 0

	override fun onUpdate() {
        val isInsideBlock = BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { it !is BlockAir }

        if (isInsideBlock) {
			mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
		}

		if (!mc.thePlayer.onGround || ticks <= 2 || !mc.thePlayer.isCollidedHorizontally || (isInsideBlock && !mc.thePlayer.isSneaking)) {
			ticks++
			return
		}
            
        val yaw = MathUtils.toRadians(mc.thePlayer.rotationYaw)

        for (i in 1..10) {
            val x = sin(yaw) * i
            val z = cos(yaw) * i

            val firstBlock = BlockUtils.getBlock(mc.thePlayer.posX - x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
            val secondBlock = BlockUtils.getBlock(mc.thePlayer.posX + x, mc.thePlayer.posY + 1, mc.thePlayer.posZ + z)

            if (firstBlock is BlockAir && secondBlock is BlockAir) {
                mc.thePlayer.setPosition(mc.thePlayer.posX - x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                break
            }
        }

        ticks = 0
	}

    override fun onBlockBB(event: BlockBBEvent) {
        val entityBoundingBox = mc.thePlayer.entityBoundingBox ?: return
        val boundingBox = event.boundingBox ?: return
        if (BlockUtils.collideBlockIntersects(entityBoundingBox) { it !is BlockAir } && boundingBox.maxY > entityBoundingBox.minY)
            event.boundingBox = AxisAlignedBB(boundingBox.maxX, entityBoundingBox.minY, boundingBox.maxZ, boundingBox.minX, boundingBox.minY, boundingBox.minZ)
    }
}
