/*
 * MinusBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/MinusMC/MinusBounce
 */
package net.minusmc.minusbounce.features.module.modules.exploit

import net.minecraft.network.Packet
import net.minecraft.network.play.client.C0CPacketInput
import net.minecraft.network.play.server.*
import net.minusmc.minusbounce.event.EventTarget
import net.minusmc.minusbounce.event.ReceivedPacketEvent
import net.minusmc.minusbounce.event.SentPacketEvent
import net.minusmc.minusbounce.event.GameLoopEvent
import net.minusmc.minusbounce.event.WorldEvent
import net.minusmc.minusbounce.features.module.Module
import net.minusmc.minusbounce.features.module.ModuleCategory
import net.minusmc.minusbounce.features.module.ModuleInfo
import net.minusmc.minusbounce.utils.misc.RandomUtils
import net.minusmc.minusbounce.value.IntRangeValue
import net.minusmc.minusbounce.value.BoolValue

/**
 * @author CCBluex
 */

@ModuleInfo(name = "PingSpoof", spacedName = "Ping Spoof", description = "Spoofs your ping to a given value.", category = ModuleCategory.EXPLOIT)
class PingSpoof: Module() {
    private val onlyPingValue = BoolValue("OnlyPing", true)
    private val delayValue = IntRangeValue("Delay", 500, 1000, 0, 1000, "ms")
    private val delayVelocity = BoolValue("DelayVelocity", false)
    private val packets = hashMapOf<Packet<*>, Long>()

    override fun onDisable() = flushPackets(true)

    @EventTarget
    fun onReceivedPacket(event: ReceivedPacketEvent) {
        mc.thePlayer ?: return

        if (event.isCancelled)
            return

        val packet = event.packet

        if (onlyPingValue.get()) {
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive) {
                event.isCancelled = true
                addPacket(packet)
            }

            return
        }

        if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive ||
            packet is S19PacketEntityStatus || (packet is S12PacketEntityVelocity && delayVelocity.get()) ||
            packet is S08PacketPlayerPosLook) {
            event.isCancelled = true
            addPacket(packet)
        }
    }

    @EventTarget
    fun onSentPacket(event: SentPacketEvent) {
        mc.thePlayer ?: return

        if (event.isCancelled)
            return

        val packet = event.packet

        if (packet is C0CPacketInput && !onlyPingValue.get()) {
            event.isCancelled = true
            addPacket(packet)
        }

    }

    private fun addPacket(packet: Packet<*>) {
        synchronized(packets) {
            val delay = RandomUtils.randomDelay(delayValue.minValue, delayValue.maxValue)
            packets[packet] = System.currentTimeMillis() + delay
        }
    }

    private fun flushPackets(flushAllPackets: Boolean) {
        synchronized(packets) {
            packets.entries.removeAll { (packet, timestamp) ->
                val canFlushPacket = timestamp <= System.currentTimeMillis()

                if (flushAllPackets || canFlushPacket)
                    mc.netHandler.addToSendQueue(packet)

                flushAllPackets || canFlushPacket
            }
        }

    }
        

    @EventTarget
    fun onGameLoop(event: GameLoopEvent) = flushPackets(false)

    @EventTarget
    fun onWorld(event: WorldEvent) = packets.clear()

}
