package net.minusmc.minusbounce.features.module.modules.exploit.disablers.matrix


import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.features.module.modules.movement.Speed
import net.minusmc.minusbounce.features.module.modules.movement.Fly
import net.minusmc.minusbounce.event.SentPacketEvent
import net.minusmc.minusbounce.event.PostMotionEvent
import net.minusmc.minusbounce.utils.InventoryUtils
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.utils.player.RotationUtils
import net.minusmc.minusbounce.utils.player.MovementUtils
import net.minusmc.minusbounce.value.BoolValue
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C09PacketHeldItemChange
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.util.BlockPos

class MatrixDisabler : DisablerMode("Matrix") {
	private val matrixNoCheck = BoolValue("NoModuleCheck", false)
	private val matrixMoveFix = BoolValue("MoveFix", true)
	private val matrixMoveOnly = BoolValue("MoveOnly", false)
	private val matrixNoMovePacket = BoolValue("NoMovePacket", true)
	private val matrixHotbarChange = BoolValue("HotbarChange", true)

	private val speedModule: Speed
		get() = MinusBounce.moduleManager[Speed::class.java]!!

	private val flyModule: Fly
		get() = MinusBounce.moduleManager[Fly::class.java]!!

	override fun onSentPacket(event: SentPacketEvent) {
		val packet = event.packet

		if (packet !is C03PacketPlayer)
			return

		if (matrixNoCheck.get() || speedModule.state || flyModule.state) {
			if (matrixNoMovePacket.get() && !packet.isMoving) {
				event.isCancelled = true
				debug("no move, cancelled")
				return
			}

			if (matrixMoveFix.get()) {
				packet.onGround = true

				if (!packet.rotating) {
					packet.rotating = true
					packet.yaw = mc.thePlayer.rotationYaw
					packet.pitch = mc.thePlayer.rotationPitch
				}
			}
		}
	}

	override fun onPostMotion(event: PostMotionEvent) {
		if (matrixMoveOnly.get() && !MovementUtils.isMoving)
			return

		if (matrixNoCheck.get() || speedModule.state || flyModule.state) {
			var changed = false
			if (matrixHotbarChange.get()) {
				val emptyHotbarSlot = InventoryUtils.findEmptyHotbarSlot()

				if (emptyHotbarSlot != -1 && emptyHotbarSlot - 36 != mc.thePlayer.inventory.currentItem) {
					PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(emptyHotbarSlot - 36))
					changed = true
					debug("found empty slot $emptyHotbarSlot, switching")
				}
			}
			
			PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, RotationUtils.serverRotation.yaw, RotationUtils.serverRotation.pitch, mc.thePlayer.onGround))
			mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(-1, -1, -1), -1, null, 0f, 0f, 0f))
			debug("sent placement")
			
			if (changed) {
				PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
				debug("switched back")
			}
		}
			
	}

}
