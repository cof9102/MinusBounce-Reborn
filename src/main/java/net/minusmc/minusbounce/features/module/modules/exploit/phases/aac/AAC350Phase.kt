package net.minusmc.minusbounce.features.module.modules.exploit.phases.aac

import net.minecraft.block.BlockAir
import net.minecraft.network.play.client.C03PacketPlayer
import net.minusmc.minusbounce.event.BlockBBEvent
import net.minusmc.minusbounce.event.SentPacketEvent
import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minusmc.minusbounce.utils.player.MovementUtils
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minusmc.minusbounce.utils.misc.MathUtils
import kotlin.math.cos
import kotlin.math.sin

class AAC350Phase : PhaseMode("AAC3.5.0") {
	private var ticks = 0

	override fun onUpdate() {
        val isInsideBlock = BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { it !is BlockAir }

		if (isInsideBlock) {
			mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
		}

		if (ticks <= 2 || !mc.thePlayer.isCollidedHorizontally || (isInsideBlock && !mc.thePlayer.isSneaking)) {
			ticks++
	        return
		}

	    val yaw = MathUtils.toRadians(mc.thePlayer.rotationYaw)

	    mc.thePlayer.setPosition(mc.thePlayer.posX - sin(yaw), mc.thePlayer.posY, mc.thePlayer.posZ + cos(yaw))
	    ticks = 0
	}
	
	override fun onSentPacket(event: SentPacketEvent) {
		val packet = event.packet
		if (packet is C03PacketPlayer) {
			val yaw = MovementUtils.directionToRadian

            packet.x -= sin(yaw) * 0.00000001
            packet.z += cos(yaw) * 0.00000001
		}
	}
}
