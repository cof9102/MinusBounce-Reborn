package net.minusmc.minusbounce.features.module.modules.exploit.disablers.verus

import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.event.ReceivedPacketEvent
import net.minusmc.minusbounce.event.SentPacketEvent
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.value.BoolValue
import net.minusmc.minusbounce.value.IntegerValue
import net.minusmc.minusbounce.utils.timer.MSTimer
import net.minusmc.minusbounce.features.module.modules.movement.Fly
import net.minusmc.minusbounce.ui.client.hud.element.elements.Notification
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.network.play.client.C0CPacketInput
import net.minecraft.init.Items

import kotlin.math.sqrt

class LatestVerusDisabler : DisablerMode("LatestVerus") {

	private val verusLobbyValue = BoolValue("LobbyCheck", true)
	private val verusFlagValue = BoolValue("Flag", true)
	private val verusSlientFlagApplyValue = BoolValue("SlientFlagApply", false)
    private val verusBufferSizeValue = IntegerValue("QueueActiveSize", 300, 0, 1000)
	private val verusFlagDelayValue = IntegerValue("FlagDelay", 40, 40, 120, " tick")
	private val verusAntiFlyCheck = BoolValue("AntiFly", true)
	private val verusFakeInput = BoolValue("FakeInput", true)
	private val verusValidPos = BoolValue("ValidPosition", true)

	private val transactionPackets = mutableListOf<C0FPacketConfirmTransaction>()

	private val msTimer = MSTimer()
	private var shouldActive = false

	private val canRun: Boolean
		get() = mc.thePlayer != null && mc.thePlayer.inventory != null && (!verusLobbyValue.get() || !mc.thePlayer.inventory.hasItem(Items.compass)) && mc.thePlayer.ticksExisted > 5

	private val flyModule: Fly
		get() = MinusBounce.moduleManager[Fly::class.java]!!

	override fun onEnable() {
		msTimer.reset()
		shouldActive = false
	}

	override fun onDisable() {
		transactionPackets.clear()
	}

	override fun onWorld() {
		transactionPackets.clear()
		msTimer.reset()
		shouldActive = false
	}

	override fun onUpdate() {
		if (verusAntiFlyCheck.get() && !shouldActive && flyModule.state) {
			flyModule.state = false
			MinusBounce.hud.addNotification(Notification("Disabler", "You can't fly before successful activation.", Notification.Type.WARNING))
			debug("no fly allowed")
		}

		if (mc.thePlayer.ticksExisted % 15 == 0 && canRun && verusFakeInput.get()) {
			mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing.coerceAtMost(0.98F), mc.thePlayer.moveForward.coerceAtMost(0.98F), mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
			debug("c0c")
		}
	}

	override fun onSentPacket(event: SentPacketEvent) {
		val packet = event.packet

		if (!canRun) {
            msTimer.reset()
            transactionPackets.clear()
			return
        }

        if (packet is C0FPacketConfirmTransaction && packet.uid !in 1..99) {
            transactionPackets.add(packet)
            event.isCancelled = true

            if(transactionPackets.size > verusBufferSizeValue.get()) {
                if (!shouldActive) {
                    shouldActive = true
                    MinusBounce.hud.addNotification(Notification("Disabler", "Successfully put Verus into sleep.", Notification.Type.SUCCESS))
                }

                PacketUtils.sendPacketNoEvent(transactionPackets.removeFirst())
            }

            debug("c0f, ${transactionPackets.size}")
        }

		if (packet is C0BPacketEntityAction) {
			event.isCancelled = true
			debug("ignored packet action")
		}

		if (packet is C03PacketPlayer) {
            if (verusFlagValue.get() && mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) {
                debug("modified c03")
				packet.y -= 11.015625 // just phase into ground instead (minimum to flag)
				packet.onGround = false
                packet.isMoving = false
            }

            if (verusValidPos.get() && packet.y % 0.015625 == 0.0) {
				packet.onGround = true
				debug("true asf")
			}
        }
	}

	override fun onReceivedPacket(event: ReceivedPacketEvent) {
		val packet = event.packet

		if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
            val x = packet.x - mc.thePlayer.posX
            val y = packet.y - mc.thePlayer.posY
            val z = packet.z - mc.thePlayer.posZ
            val diff = sqrt(x * x + y * y + z * z)
            if (diff <= 8) {
                event.isCancelled = true
                debug("flag silent accept")
                PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.yaw, packet.pitch, false))
            }
        }

	}
}
